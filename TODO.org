* TODO ! the bug in bugs/slow-load.hs, or j/6/3.hs
j/6/3 takes maybe 1/4 second to load
** learn to profile
* TODO are early and late causing silence?
* TODO ? architectural changes
** can't adjust a parameter that's not in a Museq
** need: a way to restore a Zot to reasonable parameter values
*** Idea: a map from voices to all params that have been modified in it.
*** Idea: a way to change the synth without using a Museq.
** problem: the proliferation of Museq sources (and payloads)
*** illustration of the problem
(l,time,time,Msg)
(time,Note)
etc.
*** idea: add Maybe to Note, and banish bare Msg values in a Museq
Stop using the Museq Msg type.
Instead use Museq Note',
where Note' is like Note but the synthdef is wrapped in a Maybe.
** problem: can't insert silence into an abstract pattern generator
*** illustration of the problem
seq d e f = mmh [ (0, d)
                , (1, e)
                , (1.5, f) ]
*** one solution: define the endpoints
seq d e f = mmh [ (0, d)
                , (1, e)
                , (1.5, f) ]
*** another solution: an mmh that expects Maybe values
* TODO stereo
http://www.cs.cmu.edu/~music/icm-online/readings/panlaws/index.html
** try first: the "constant power" rule
Let L(theta) = cos theta,
    R(theta) = sin theta
where theta ranges from 0 (left) to pi/2 (right)
** if that makes the center position too loud
try the "compromise" described later in the article
* problems
** changing _sup or _dur can ruin a Sampler sequence
*** easier solution: manage Sampler trigger values from Dispatch
Don't include "trigger" as a parameter in a Museq.
Instead, add trigger=1 to every Museq message,
and follow it closely by a trigger=0.
*** hard (current) solution: manage trigger on-off within Museqs
It ought to be that mkMuseqRt puts the trigger=0 right between
the trigger=1 and the next event, rather than closer to the trigger=1.
But then changes to the _dur or _sup of the sequence should ensure
that any time the last message is "trigger=1", it is followed by "trigger=0".
** can't understand why it souonds like it does
** can't adjust individual notes
* TODO easy
** amplitude group for all drums, all pitched tracks
** ride cymbal
* bugs
bugs/slow-load.hs
bugs/stack-interference/
* graph
** split rels v. reify
*** TODO how
**** add type: Reif
 RAtom = RScale [Number]
       | RStr String
       | RNum Number
 RMuseq = RMScale (Museq String Scale)
        | RMNum (Museq String Num)
        | RMMsg (Museq String Msg)
        | RMNote (Museq String Note)
        | RMMeta (Museq String (Museq -> Museq))
 RFunction = RNum2 (Number -> Number)
           | RNum3 (Number -> Number -> Number)
           | RScale2 ([Number] -> [Number])
           | RTransform (Museq -> Museq)
           | RJoin (Museq -> Museq -> Museq)
 Reif = ReifAtom RAtom
      | ReifFunc RFunction
      | ReifParam String Number
      | ReifAt Time Reif
      | ReifToSynth SynthDefEnum (Museq String Msg)
**** add: eval :: Disp -> Rslt -> Addr -> Reif
**** add play  :: Reif -> IO ()
**** leave unchanged: evalSynthParam :: Rslt -> Addr -> Either String Msg
**** make polymorphic: evalParamEvent :: Rslt -> Addr -> Either String a
*** why
 The "_ in <pattern name> at <time>"
 relationship is polymorphic in its first member.

 My two options are to split it into multiple rels
 ("param _ in _ at _", "scale _ in _ at _", etc.)
 or to reify the elements of Dispatch into a single type.

 The first is nicer to code,
 but it means duplicating lots of functions,
 which sucks for the user who has to remember them.
** extend graph language
 parameters (on, amp)
 functions
 function patterns
 scale patterns
** play song from UI
*** modify Hode to let using code add to the UI
** how to cut through the boilerplate in Vivid.Hode?
 HExpr helped, but there ought to be a way to build all those functions from a single HExprF.
* TODO more
** easy shorthand
*** functions to change parameters
per parameter, a function to change it
per parameter, a function to set it if absent
  mmho does something like this for "on"
per parameter, a function to change it or set it if absent
*** noteToFreq = ops [("freq", (*) 300 . \p -> 2**(p/12))]
*** mmho
**** rewrite mmho so that duration is last
**** versions that don't expect a name
**** a version that zips (map RTime [0..]) to a list of payloads
and computes the duration automatically (as the length of the list)
*** a chAll that adds names automatically
** timbres
** drums
*** important ? missing drums
tom -- low, high
cymbal -- ride, crash, cowbell
woodblock
clap
tambourine
** to prevent loud unisons during polyphonic merges
Use per-voice explicit or random phase|freq variation.
This way, when a polyphonic Museq is joined with another,
and the poly one is silent,
the many voices will not create huge waveform peaks.
** ? the Join functions that accept two kinds of labels are dumb
They should accept only one kind, in the Monoid class,
and join them if needed with (<>).
* leads
./Dispatch/Dispatch.hs: -- todo ? awkward : The Ev' label gets repeated within the Action.
* also whatever is in org/todo.org
* the best licks
2/3
3
7/1
1/3
