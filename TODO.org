* graph
** split rels v. reify
*** TODO how
**** add type: Reif
 RAtom = RScale [Number]
       | RStr String
       | RNum Number
 RMuseq = RMScale (Museq String Scale)
        | RMNum (Museq String Num)
        | RMMsg (Museq String Msg)
        | RMNote (Museq String Note)
        | RMMeta (Museq String (Museq -> Museq))
 RFunction = RNum2 (Number -> Number)
           | RNum3 (Number -> Number -> Number)
           | RScale2 ([Number] -> [Number])
           | RTransform (Museq -> Museq)
           | RJoin (Museq -> Museq -> Museq)
 Reif = ReifAtom RAtom
      | ReifFunc RFunction
      | ReifParam String Number
      | ReifAt Time Reif
      | ReifToSynth SynthDefEnum (Museq String Msg)
**** add: eval :: Disp -> Rslt -> Addr -> Reif
**** add play  :: Reif -> IO ()
**** leave unchanged: evalSynthParam :: Rslt -> Addr -> Either String Msg
**** make polymorphic: evalParamEvent :: Rslt -> Addr -> Either String a
*** why
 The "_ in <pattern name> at <time>"
 relationship is polymorphic in its first member.

 My two options are to split it into multiple rels
 ("param _ in _ at _", "scale _ in _ at _", etc.)
 or to reify the elements of Dispatch into a single type.

 The first is nicer to code,
 but it means duplicating lots of functions,
 which sucks for the user who has to remember them.
** extend graph language
 parameters (on, amp)
 functions
 function patterns
 scale patterns
** play song from UI
*** modify Hode to let using code add to the UI
** how to cut through the boilerplate in Vivid.Hode?
 HExpr helped, but there ought to be a way to build all those functions from a single HExprF.
* problems
** can't adjust individual notes
** can't understand why it souonds like it does
* todo
** easy shorthand
*** functions to change parameters
per parameter, a function to change it
per parameter, a function to set it if absent
  mmho does something like this for "on"
per parameter, a function to change it or set it if absent
*** noteToFreq = ops [("freq", (*) 300 . \p -> 2**(p/12))]
*** mmho
**** rewrite mmho so that duration is last\
**** versions that don't expect a name
**** a version that zips (map RTime [0..]) to a list of payloads
and computes the duration automatically (as the length of the list)
*** a chAll that adds names automatically
** timbres
** drums
*** for how to load a buffer into a synth.
See Tom's first message here:
https://we.lurk.org/hyperkitty/list/livecode@we.lurk.org/thread/6JD5SHXPQQ25VZH4PVKIR5Y7HEAPXZWL/
*** for where it hooks into my code
**** The sample buffers will have to be created when the Dispatch is.
**** replace and replaceAll call actNew,
which will have to then use those sample buffers to create the new Synths.
**** There will be one synth (type) for each sample -- kick, snare, hat ...
**** A single `Museq Note` can send to synths of multiple types.
*** important ? missing drums
tom -- low, high
cymbal -- ride, crash, cowbell
woodblock
clap
tambourine
** to prevent loud unisons during polyphonic merges
Use per-voice explicit or random phase|freq variation.
This way, when a polyphonic Museq is joined with another,
and the poly one is silent,
the many voices will not create huge waveform peaks.
** ? the Join functions that accept two kinds of labels are dumb
They should accept only one kind, in the Monoid class,
and join them if needed with (<>).
* leads
./Dispatch/Dispatch.hs: -- todo ? awkward : The Ev' label gets repeated within the Action.
* also whatever is in org/todo.org
