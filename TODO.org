* report "backend is unhealthy" error
https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/runtime-control.html
* TODO ! the bug in bugs/slow-load.hs, or j/6/3.hs
** things that are slow
    inherited
 %time %alloc COST CENTRE                                                        MODULE                               SRC

 48.6   45.9      meta._meta                                                     Dispatch.Join                        src/Dispatch/Join.hs:(300,3)-(314,55)
 48.4   45.8       meta._meta.evs                                                Dispatch.Join                        src/Dispatch/Join.hs:(310,5)-(314,55)
 11.0   15.8        arc                                                          Dispatch.Museq                       src/Dispatch/Museq.hs:(402,1)-(427,75)
 34.4   21.0        main.wave                                                    Main                                 app/Main.hs:(45,7)-(46,28)
 34.4   21.0         early                                                       Dispatch.Transform                   src/Dispatch/Transform.hs:(37,1)-(41,62)
 29.7   14.7          sortMuseq                                                  Dispatch.Museq                       src/Dispatch/Museq.hs:(376,1)-(379,30)
 25.8   14.7           #.                                                        Data.Profunctor.Unsafe               src/Data/Profunctor/Unsafe.hs:175:3-71
 25.8   14.7            sortMuseq.\                                              Dispatch.Museq                       src/Dispatch/Museq.hs:(377,9)-(379,30)

 46.2   49.9      rootScale                                                      Dispatch.Join                        src/Dispatch/Join.hs:(287,1)-(289,30)
 27.3   16.2       scale                                                         Dispatch.Join                        src/Dispatch/Join.hs:(269,1)-(283,46)
 27.3   16.2        merge                                                        Dispatch.Join                        src/Dispatch/Join.hs:(179,1)-(194,51)
 27.3   16.1         merge._merge                                                Dispatch.Join                        src/Dispatch/Join.hs:(183,3)-(194,51)
 21.2    9.4          merge._merge.yps                                           Dispatch.Join                        src/Dispatch/Join.hs:194:5-51
 21.2    9.4           partitionAndGroupEventsAtBoundaries                       Dispatch.Internal.Join               src/Dispatch/Internal/Join.hs:(92,1)-(97,48)
 21.0    9.3            partitionAndGroupEventsAtBoundaries.partitionEv          Dispatch.Internal.Join               src/Dispatch/Internal/Join.hs:(95,7)-(96,53)
 21.0    9.3             partitionArcAtTimes                                     Dispatch.Internal.Join               src/Dispatch/Internal/Join.hs:(81,1)-(86,54)
 14.7    9.3              >                                                      Dispatch.Types                       src/Dispatch/Types.hs:57:42-44
  5.5    5.8          merge._merge.ys                                            Dispatch.Join                        src/Dispatch/Join.hs:191:5-54
  5.5    5.8           unsafeExplicitReps                                        Dispatch.Internal.Join               src/Dispatch/Internal/Join.hs:(48,1)-(63,76)
  5.4    5.7            unsafeExplicitReps.reps                                  Dispatch.Internal.Join               src/Dispatch/Internal/Join.hs:63:3-76
  5.0    5.7             divideAtMaxima                                          Util                                 src/Util.hs:(218,1)-(226,27)
  5.0    5.7              divideAtMaxima.go                                      Util                                 src/Util.hs:(223,3)-(226,27)
  5.0    5.7               divideAtMaxima.go.(...)                               Util                                 src/Util.hs:225:9-49
 18.9   33.7       root                                                          Dispatch.Join                        src/Dispatch/Join.hs:(263,1)-(264,36)
 16.1   26.3        meta                                                         Dispatch.Join                        src/Dispatch/Join.hs:(295,1)-(314,55)
 16.1   26.2         meta._meta                                                  Dispatch.Join                        src/Dispatch/Join.hs:(300,3)-(314,55)
 15.7   25.9          meta._meta.evs                                             Dispatch.Join                        src/Dispatch/Join.hs:(310,5)-(314,55)
 12.2   16.7           arc                                                       Dispatch.Museq                       src/Dispatch/Museq.hs:(402,1)-(427,75)

** how to profile
*** I think these both work
stack run --profile -- vivid-dispatch-exe --ghci-options="-O"
stack exec -- vivid-dispatch-exe +RTS -p
*** more supposedly-good options
(according to http://www.fatvat.co.uk/2010/08/speeding-up-ants-program.html)
-prof - Enables profiling
-caf-all - Constant Applicative form for all top-level items (constant costs, one for each module.)
-auto-all - Cost-centre analysis for every top-level function
* TODO ? architectural changes
** can't adjust a parameter that's not in a Museq
** need: a way to restore a Zot to reasonable parameter values
*** Idea: a map from voices to all params that have been modified in it.
*** Idea: a way to change the synth without using a Museq.
** problem: the proliferation of Museq sources (and payloads)
*** illustration of the problem
(l,time,time,Msg)
(time,Note)
etc.
*** idea: add Maybe to Note, and banish bare Msg values in a Museq
Stop using the Museq Msg type.
Instead use Museq Note',
where Note' is like Note but the synthdef is wrapped in a Maybe.
** problem: can't insert silence into an abstract pattern generator
*** illustration of the problem
seq d e f = mmh [ (0, d)
                , (1, e)
                , (1.5, f) ]
*** one solution: define the endpoints
seq d e f = mm [ (0, 1, d)
               , (1, 1.25, e) -- there's a silence from 1.25 to 1.5
               , (1.5, 2, f) ]
*** another solution: an mmh that expects Maybe values
* problems
** changing _sup or _dur can ruin a Sampler sequence
*** easier solution: manage Sampler trigger values from Dispatch
Don't include "trigger" as a parameter in a Museq.
Instead, add trigger=1 to every Museq message,
and follow it closely by a trigger=0.
*** hard (current) solution: manage trigger on-off within Museqs
It ought to be that mkMuseqRt puts the trigger=0 right between
the trigger=1 and the next event, rather than closer to the trigger=1.
But then changes to the _dur or _sup of the sequence should ensure
that any time the last message is "trigger=1", it is followed by "trigger=0".
** can't understand why it souonds like it does
** can't adjust individual notes
* TODO easy
** amplitude group for all drums, all pitched tracks
** ride cymbal
** redundant: ev4 ~ mkEv
** stereo
 http://www.cs.cmu.edu/~music/icm-online/readings/panlaws/index.html
*** try first: the "constant power" rule
 Let L(theta) = cos theta,
     R(theta) = sin theta
 where theta ranges from 0 (left) to pi/2 (right)
*** if that makes the center position too loud
 try the "compromise" described later in the article

* graph
** split rels v. reify
*** TODO how
**** add type: Reif
 RAtom = RScale [Number]
       | RStr String
       | RNum Number
 RMuseq = RMScale (Museq String Scale)
        | RMNum (Museq String Num)
        | RMMsg (Museq String Msg)
        | RMNote (Museq String Note)
        | RMMeta (Museq String (Museq -> Museq))
 RFunction = RNum2 (Number -> Number)
           | RNum3 (Number -> Number -> Number)
           | RScale2 ([Number] -> [Number])
           | RTransform (Museq -> Museq)
           | RJoin (Museq -> Museq -> Museq)
 Reif = ReifAtom RAtom
      | ReifFunc RFunction
      | ReifParam String Number
      | ReifAt Time Reif
      | ReifToSynth SynthDefEnum (Museq String Msg)
**** add: eval :: Disp -> Rslt -> Addr -> Reif
**** add play  :: Reif -> IO ()
**** leave unchanged: evalSynthParam :: Rslt -> Addr -> Either String Msg
**** make polymorphic: evalParamEvent :: Rslt -> Addr -> Either String a
*** why
 The "_ in <pattern name> at <time>"
 relationship is polymorphic in its first member.

 My two options are to split it into multiple rels
 ("param _ in _ at _", "scale _ in _ at _", etc.)
 or to reify the elements of Dispatch into a single type.

 The first is nicer to code,
 but it means duplicating lots of functions,
 which sucks for the user who has to remember them.
** extend graph language
 parameters (on, amp)
 functions
 function patterns
 scale patterns
** play song from UI
*** modify Hode to let using code add to the UI
** how to cut through the boilerplate in Vivid.Hode?
 HExpr helped, but there ought to be a way to build all those functions from a single HExprF.
* TODO more
** easy shorthand
*** functions to change parameters
per parameter, a function to change it
per parameter, a function to set it if absent
  mmho does something like this for "on"
per parameter, a function to change it or set it if absent
*** noteToFreq = ops [("freq", (*) 300 . \p -> 2**(p/12))]
*** mmho
**** rewrite mmho so that duration is last
**** versions that don't expect a name
**** a version that zips (map RTime [0..]) to a list of payloads
and computes the duration automatically (as the length of the list)
*** a chAll that adds names automatically
** timbres
** drums
*** important ? missing drums
tom -- low, high
cymbal -- ride, crash, cowbell
woodblock
clap
tambourine
** to prevent loud unisons during polyphonic merges
Use per-voice explicit or random phase|freq variation.
This way, when a polyphonic Museq is joined with another,
and the poly one is silent,
the many voices will not create huge waveform peaks.
** ? the Join functions that accept two kinds of labels are dumb
They should accept only one kind, in the Monoid class,
and join them if needed with (<>).
* PITFALLS
** timeForBothToPlayThrough v. timeForBothToRepeat
*** the tradeoff
**** timeForBothToPlayThrough is "safer"
stack used to be written in terms of timeForBothToRepeat,
but that led to this bug

> c2 = dur .~ 2 $ mmh 1 $ pre2 "" $ [ (0, "a") ]
> c2
Museq {_dur = 2 % 1, _sup = 1 % 1, _vec = [Event {_evLabel = "", _evArc = (0 % 1,1 % 1), _evData = "a"}]}
> stack c2 c2
Museq {_dur = 2 % 1, _sup = 1 % 1, _vec = []}
**** timeForBothToRepeat can be more efficient
In the case of stack, if the time to repeat is less than the time to play through,
the result of stacking two things can be a lot smaller if they are not looped all the way through.
*** solutions
**** it's not really that timeForBothToPlayThrough is "safer"
 I'm sure there's a good way to do it -- just, like, check that it won't fuck up.
**** another, also best-of-both-worlds, solution
 Use timeToPlayThrough,
 but then rewrite the result more concisely if possible.
*** might be a problem with merge
although I've only actually noticed it in stack
* leads
./Dispatch/Dispatch.hs: -- todo ? awkward : The Ev' label gets repeated within the Action.
* also whatever is in org/todo.org
* the best licks
2/3
3
7/1
1/3
