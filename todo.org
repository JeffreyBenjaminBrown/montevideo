* rewriting DistribLoop
** maybe adding frameDuration to startRender is unnecessary.
*** If so, adjust this function, and also replaceAll, chTempo, etc. -- maybe everything that calls getTime.
** when to create, free, send, modify 
*** switch comes at time t, next render at time n, render period p
*** add synths to registry immediately
*** send silences to deleted synths at n+p
*** delete synths from registry at n+1.5p
*** modify the tMuseqs immediately (at n they'll get rendered for [n+p,n+2p))
* supercollider mysteries
** envelopes
** many voices to one distortion
** slow changes, e.g. for slide guitar
* features to add, in roughly cumulative order
** functions over loops
*** *apply
*** *merge (multiplicative or additive (? per parameter))
**** e.g., merging freq of 2 and freq of 440 gives freq of 880
**** ? does it apply to a general Museq a, or only Museq Msg, or Museq Action?
**** ? consider mismatched durations, sups
**** ? allow user to specify alternative strategies for particular parameters
***** e.g. "merge these all with (\*), except merge amp with (+)"
*** overParams :: [(ParamString, Double -> Double)] -> Museq -> Museq
*** dropParams, keepParams :: [ParamString] -> Museq -> Museq
*** space: play a duration n < k loop over duration k. (Hard; see Tidal.epic.)
** scales, harmonies
** distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
