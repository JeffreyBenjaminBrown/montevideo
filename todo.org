* changing tempo: options
** *change tempo only when all Museqs are waiting
*** if any of them is not, wait for a random time in 5-10 ms, then retry
** keep a global rendering frame rate
** keep a global Museq, and change tempo when it's waiting
** deal with it later
* features to add, in cumulative order
** keep, run a loop
*** then multiple loops of varying durations
** make functions for manipulating loops
*** spend a long time on this
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* more features, not ordered
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** A collection of concurrent notes has to be distributed across synths
*** automatically, rather than requiring the user to say which go where.
* constraints
** want to change tempo
** want to start without delay
** user might redefine loop halfway through
** loops will have different lengths
** dubious ? the user sees many Museqs, but the loop keeps one master Museq
*** in favor: harmony
**** this might make it easier to write across-Museq harmony functions
*** against: cpu-costly
**** I would be culling through more notes (e.g. drums) than needed
**** Polyrhythms could make the global Museq way longer than its components
