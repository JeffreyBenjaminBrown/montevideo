* change the representations
** Wait should not be a kind of Action;
*** delays should instead be programmed from each Museq
*** and scheduled: pick a delay time taking current time into account
* features to add, in cumulative order
** represent a loop
*** a vector of (Time, Action) pairs, sorted on Time, starting at Time 0
*** and a duration >= the greatest Time in the vector
** keep a loop
*** then multiple loops of varying durations
** make functions for manipulating loops
*** spend a long time on this
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs

* more features, not ordered
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** A collection of concurrent notes has to be distributed across synths
*** automatically, rather than requiring the user to say which go where.
* constraints
** want to change tempo
** want to start without delay
** user might redefine loop halfway through
** loops will have different lengths
** want sequences to be vectors
*** they're easier to work with than functions
