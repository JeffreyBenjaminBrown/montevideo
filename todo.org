* todo next >>> use `sup` in append
** the algorithm
lcm (dur x) (sup x) / (sup x) = how many sups for x to finish at phase 0
 call that `nToRep x`
lcm (nToRep m) (nToRep n) = how many sups for both to finish at phase 0
repeat both that many times
chop each on every _dur "Rseconds"
interleave those
** examples
m = dur 2, sup 4, vec [0 a, 2 b]
n = dur 1, sup 1, vec [0 c]
m++n = dur 3, sup 6, vec [0 a, 2 c, 3 b, 5 c]

m = dur 2, sup 4, vec [0 a, 2 b]
n = dur 1, sup 2, vec [0 c, 1 d]
m++n = dur 3, sup 6, vec [0 a, 2 c, 3 b, 5 d]

m = dur 2, sup 3, vec [0 a]
n = dur 1, sup 1, vec [0 b]
m++n = dur 3, sup 9, vec [0 a, 2 b, 4 a, 5 b, 8 b]

m = dur 2, sup 1, vec [0 a]
n = dur 1, sup 1, vec [0 b]
m++n = dur 3, sup 3, vec [0 a, 1 a, 2 b]

m = dur 3, sup 2, vec [0 a]
n = dur 1, sup 1, vec [0 b]
m++n = dur 4, sup 8, vec [0 a, 2 a, 3 b, 5 a, 7 b]
* sparse requires a major type rewrite
** there should be two durations to a Museq: the glue-duration and the RTime-supremum
** if in Museq x the glue-duration is half the RTime-sup, and x is glued to y, then the sound is of half of x, then y, then the other half of x, then y again
** if in Museq x the glueDur is twice the supDur, then gluing x to y would result in the sound of x played twice (each iteration being glueDur in length) followed by y played once
* supercollider mysteries
** envelopes
** many voices to one distortion
** slow changes, e.g. for slide guitar
* features to add, in roughly cumulative order
** functions over loops
*** merge (multiplicative or additive (? per parameter))
**** e.g., merging freq of 2 and freq of 440 gives freq of 880
*** apply
*** early, late, slow, fast, dense, sparse
*** rotate t = fast t . sparse t
*** rep n = slow n . dense n -- the name `repeat` is taken
*** space: play a duration n < k loop over duration k. (Hard; see Tidal.epic.)
*** onParams :: [(ParamString, Double -> Double)] -> Museq -> Museq
*** dropParams, keepParams :: [ParamString] -> Museq -> Museq

** distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** scales, harmonies
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* safer (and better) timing
** The problem (in Distrib.distribLoop)
*** Currently I use a "anything that plays in epsilon seconds plays now" hack.
*** That hack is not foolproof; if GHC delayed a long time, it would skip an Action.
*** Also it introduces inaccuracies.
** Two solutions, neither clearly easier (but the first clearly better)
*** Hand the timing off to SuperCollider
**** This would mean, rather than rendering after each collection of concurrent Actions, rendering a bunch of those in advance.
**** If any of those Actions has an error, write the error to errors.txt immediately. Include the time it was discovered, the time it was supposed to play, and the name of the Museq it came from. 
*** Track more stuff
**** Each `Museq` tracks when it last played
**** `distribLoop` tracks when it's supposed to wake up.
**** If, when `distribLoop` awakens, it discovers a Museq which last played before the scheduled awakening, which should have played something since, then that skipped thing gets played immediately.
* problems, minor
** Transform.stack wastes space
*** stacking two Museqs without a simple duration ratio wastes lots of space
*** alternative: a Museq is a Set of Museq's, where Museq' = the old thing
**** but then appending two Museq's will mean ... I don't even know what
