* supercollider mysteries
** envelopes
** many voices to one distortion
** slow changes, e.g. for slide guitar
* features to add, in roughly cumulative order
** f :: SynthDefEnum -> SynthName -> [Msg] -> [Action]
** once :: [Action] -> IO ()
*** good for setting parameters that don't change frequently
*** good for creating, destroying synths -- but better to automate that
** give Museq a type parameter
*** Distrib uses (Museq Action). 
*** Will be useful too: Museq Msg, Museq (Msg -> Msg) ...
** functions over loops
*** append, stack
*** merge (multiplicative or additive (? per parameter))
**** e.g., merging freq of 2 and freq of 440 gives freq of 880
*** apply
*** rev -- the name `reverse` is taken
*** early, late, slow, fast, dense, sparse
*** rotate t = fast t . sparse t
*** rep n = slow n . dense n -- the name `repeat` is taken
*** space: play a duration n < k loop over duration k. (Hard; see Tidal.epic.)
*** onParams :: [(ParamString, Double -> Double)] -> Museq -> Museq
*** dropParams, keepParams :: [ParamString] -> Museq -> Museq
** distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** scales, harmonies
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* safer (and better) timing
** The problem (in Distrib.distribLoop)
*** Currently I use a "anything that plays in epsilon seconds plays now" hack.
*** That hack is not foolproof; if GHC delayed a long time, it would skip an Action.
*** Also it introduces inaccuracies.
** Two solutions, neither clearly easier (but the first clearly better)
*** Hand the timing off to SuperCollider
**** This would mean, rather than rendering after each collection of concurrent Actions, rendering a bunch of those in advance.
**** If any of those Actions has an error, write the error to errors.txt immediately. Include the time it was discovered, the time it was supposed to play, and the name of the Museq it came from. 
*** Track more stuff
**** Each `Museq` tracks when it last played
**** `distribLoop` tracks when it's supposed to wake up.
**** If, when `distribLoop` awakens, it discovers a Museq which last played before the scheduled awakening, which should have played something since, then that skipped thing gets played immediately.
