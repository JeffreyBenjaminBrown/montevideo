* changing tempo: options
** *change tempo only when all Museqs are waiting
*** if any of them is not, wait for a random time in 5-10 ms, then retry
** keep a global rendering frame rate
** keep a global Museq, and change tempo when it's waiting
** deal with it later
* features to add, in cumulative order
** run multiple loops of varying durations
** make functions for manipulating loops
*** spend a long time on this
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* more features, not ordered
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** A collection of concurrent notes has to be distributed across synths
*** automatically, rather than requiring the user to say which go where.
* constraints
** want to change tempo
** user might redefine loop halfway through
