* workflow : wishes, mysteries
** ? changing (museqs dist): voices must appear, and must vanish not too soon
*** make a "diffSynths" function, to see what needs creating|freeing
*** Museq Msg v. Museq Action
*** anything disappearing: send amp=0 first (ideally with a smoother in the synth, and then wait for that smoothing), then free it
*** ? anything appearing : make those unused synths well in advance
*** "change (mTimeMuseqs dist)" makes synths, then waits for input to press akey, whereupon it changes the museqs
** ? implicit note off
* supercollider mysteries
** envelopes
** many voices to one distortion
** slow changes, e.g. for slide guitar
* features to add, in roughly cumulative order
** functions over loops
*** *merge (multiplicative or additive (? per parameter))
**** e.g., merging freq of 2 and freq of 440 gives freq of 880
**** ? does it apply to a general Museq a, or only Museq Msg, or Museq Action?
**** ? consider mismatched durations, sups
**** ? allow user to specify alternative strategies for particular parameters
***** e.g. "merge these all with (\*), except merge amp with (+)"
*** *apply
*** onParams :: [(ParamString, Double -> Double)] -> Museq -> Museq
*** dropParams, keepParams :: [ParamString] -> Museq -> Museq
*** space: play a duration n < k loop over duration k. (Hard; see Tidal.epic.)
** scales, harmonies
** distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* safer (and better) timing
** The problem (in Distrib.distribLoop)
*** Currently I use a "anything that plays in epsilon seconds plays now" hack.
*** That hack is not foolproof; if GHC delayed a long time, it would skip an Action.
*** Also it introduces inaccuracies.
** Two solutions, neither clearly easier (but the first clearly better)
*** Hand the timing off to SuperCollider
**** This would mean, rather than rendering after each collection of concurrent Actions, rendering a bunch of those in advance.
**** If any of those Actions has an error, write the error to errors.txt immediately. Include the time it was discovered, the time it was supposed to play, and the name of the Museq it came from. 
*** Track more stuff
**** Each `Museq` tracks when it last played
**** `distribLoop` tracks when it's supposed to wake up.
**** If, when `distribLoop` awakens, it discovers a Museq which last played before the scheduled awakening, which should have played something since, then that skipped thing gets played immediately.
* problems, minor
** Transform.stack wastes space
*** stacking two Museqs without a simple duration ratio wastes lots of space
*** alternative: a Museq is a Set of Museq's, where Museq' = the old thing
**** but then appending two Museq's will mean ... I don't even know what
