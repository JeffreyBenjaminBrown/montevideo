* features to add, in cumulative order
** f :: SynthDefEnum -> SynthName -> [Msg] -> [Action]
** give Museq a type parameter
*** Distrib uses (Museq Msg). Museq (Msg -> Msg) will be useful, etc.
** make functions for manipulating loops
*** spend a long time on this
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** Distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* safer (and better) timing
** The problem (in Distrib.distribLoop)
*** Currently I use a "anything that plays in epsilon seconds plays now" hack.
*** That hack is not foolproof; if GHC delayed a long time, it would skip an Action.
*** Also it introduces inaccuracies.
** Two solutions, neither clearly easier (but the first clearly better)
*** Hand the timing off to SuperCollider
**** This would mean, rather than rendering after each collection of concurrent Actions, rendering a bunch of those in advance.
**** If any of those Actions has an error, write the error to errors.txt immediately. Include the time it was discovered, the time it was supposed to play, and the name of the Museq it came from. 
*** Track more stuff
**** Each `Museq` tracks when it last played
**** `distribLoop` tracks when it's supposed to wake up.
**** If, when `distribLoop` awakens, it discovers a Museq which last played before the scheduled awakening, which should have played something since, then that skipped thing gets played immediately.
