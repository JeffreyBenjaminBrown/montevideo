* change synthReg to be a single MVar
** when it is used, all its fields are used at once, so that's safe
* schedule :: SynthRegister -> [(Time,Action)] -> IO ()
* rename (where true) period -> tempoPeriod
* delete the (Time,) from the mTimeMuseqs
* rewriting DistribLoop
** next: act'At should schedule the MVar changes
*** each function it calls (newAction'At, etc) might as well take the Action' rather than its pieces
*** use takeMVar and putMVar to be sure they don't step on each other
** chTempo might need modification
** one global config parameter
*** frameDuration
*** in the new DistribLoop, won't need an epsilon wait before starting
**** because rendering is already delayed until the next frame
** when to create, free, send, modify 
*** TODO danger ? the tMuseqs could be mid-render when changed
*** switch comes at time t, next render at time n, render period p
*** use forkIO to avoid waiting for things to finish
*** add synths to registry immediately
*** send silences to deleted synths at n+p
*** delete synths from registry at n+1.5p
*** modify the tMuseqs immediately (at n they'll get rendered for [n+p,n+2p))
* supercollider mysteries
** envelopes
** many voices to one distortion
** slow changes, e.g. for slide guitar
* features to add, in roughly cumulative order
** functions over loops
*** *merge (multiplicative or additive (? per parameter))
**** e.g., merging freq of 2 and freq of 440 gives freq of 880
**** ? does it apply to a general Museq a, or only Museq Msg, or Museq Action?
**** ? consider mismatched durations, sups
**** ? allow user to specify alternative strategies for particular parameters
***** e.g. "merge these all with (\*), except merge amp with (+)"
*** *apply
*** overParams :: [(ParamString, Double -> Double)] -> Museq -> Museq
*** dropParams, keepParams :: [ParamString] -> Museq -> Museq
*** space: play a duration n < k loop over duration k. (Hard; see Tidal.epic.)
** scales, harmonies
** distribute concurrent notes across synths
*** automatically, rather than requiring the user to say which go where.
** A synth plan can be represented multiple ways:
*** Each has a total duration
*** An ordered sequence of (duration, synth message) pairs.
*** Extant synths are never off; time between notes = amplitude zero
** parse a DSL for it
*** seems much easier to make the DSL after the functions it will encode
*** for every bit of terse punctuation, include a verbal alternative
**** => easier to remember, easier to search for language constructs
* safer (and better) timing
** "change "put" for more precise start time
*** after making synths, it could wait for the user to press a key; and then change the museqs, for a snappier response
** Distrib.distribLoop
*** The problem (in Distrib.distribLoop)
**** Currently I use a "anything that plays in epsilon seconds plays now" hack.
**** That hack is not foolproof; if GHC delayed a long time, it would skip an Action.
**** Also it introduces inaccuracies.
*** Two solutions, neither clearly easier (but the first clearly better)
**** Hand the timing off to SuperCollider
***** This would mean, rather than rendering after each collection of concurrent Actions, rendering a bunch of those in advance.
***** If any of those Actions has an error, write the error to errors.txt immediately. Include the time it was discovered, the time it was supposed to play, and the name of the Museq it came from. 
**** Track more stuff
***** Each `Museq` tracks when it last played
***** `distribLoop` tracks when it's supposed to wake up.
***** If, when `distribLoop` awakens, it discovers a Museq which last played before the scheduled awakening, which should have played something since, then that skipped thing gets played immediately.
